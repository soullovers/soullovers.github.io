---
layout: post
title: "쿠버네티스 소개"
categories:
  - dev
tags:
  - kubernates
---



# 컨테이너
> - 컨테이너는 실행에 필요한 모든 파일을 포함하여 전체 런타임 환경에서 애플리케이션을 패키지화하고 분리하는 기술
> - 전체 기능을 유지하면서 컨테이너화된 애플리케이션을 환경(개발, 테스트, 생산 등) 간에 쉽게 이동할 수 있다.
> - 컨테이너 파이프라인에 보안을 구축하고 인프라를 보호하여 컨테이너의 안정성과 확장성 및 신뢰성을 보장
> - 애플리케이션 패키징 매커니즘과 실행환경의 분리로 개발자는 애플리케이션에 집중할 수 있고 운영 팀은 인프라에 주력할 수 있다.
> - 컨테이너 기술은 애플리케이션 개발 및 배포를 간소화하고 가속화하고 조정하는 데 도움이 된다.

## 컨테이너 핵심기술
#### 컨트롤그룹 (cgroups)
- 프로세스 또는 프로세스 그룹의 리소스 사용을 제어하고 제한하는 커널 기능
- CPU, 메모리, 디스크, 네트워크 자원


#### 네임스페이스 (namespace)
- 프로세스 트리, 사용자 계정, 파일 시스템, IPC등을 격리 시킨 호스트와 별개의 공간


#### union filesystem
- 유니온 파일 시스템 형식 (aufs, btrfs, devicemapper)
- 동일한 Image를 바탕으로 기동된 Container는 각각의 Container Layer만 추가되며, Image Layer는 공유하여 사용한다.
- 이러한 특성으로 인해, Docker Container는 더욱 가벼워지고 기동 속도가 빨라지는 것이다.



## 컨테이너의 장점
- 기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임.
- 지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 쉽게 롤백할 수 있다.
- 개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 디커플된다.
- 개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.
- 클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine 및 다른 어디에서든 구동된다.
- 애플리케이션 중심 관리: 가상 하드웨어의 OS에서 애플리케이션을 구동하는 수준에서 OS의 논리적인 자원을 사용하여 애플리케이션을 구동하는 수준으로 추상화 수준이 높아진다.
- 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.
- 자원 격리: 애플리케이션 성능을 예측할 수 있다.
- 자원 사용량: 고효율 고집적.


# 쿠버네티스
> - 다수의 컨테이너를 자동으로 운영하기 위한 오케스트레이션 도구
> - 구글이 구글이 자사 서비스를 위해 개발했던 Borg에서 얻은 운영 노하우를 2014년 오픈소스로 공개한 것 
> - 고대그리스어로 항해사
> - 약어로 k8s
> - 많은 시스템을 통합, 컨테이너를 다루기 위한 API제공
> - 개발자는 시스템 관리자의 도움없이 쿠버네티스를 통해 어플리케이션을 배포
> - 사실상의 컨테이너 관리 표준


## 쿠버네티스의 특징
### 서비스 디스커버리와 로드 밸런싱
- 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.

### 스토리지 오케스트레이션 
- 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.

### 자동화된 롤아웃과 롤백 
- 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든리소스를 새 컨테이너에 적용할 수 있다.

### 자동화된 빈 패킹(bin packing) 
- 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수있도록 해준다.

### 자동화된 복구(self-healing)
- 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.

### 시크릿과 구성 관리 
- 쿠버네티스를 사용하면 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.






